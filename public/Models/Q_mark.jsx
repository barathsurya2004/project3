/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 q_mark.glb 
*/

import React, { useContext, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useGSAP } from "@gsap/react";
import gsap from "gsap";
import { ScrollTrigger } from "gsap/all";
import { useFrame } from "@react-three/fiber";
import { Context } from "../../src/context";
gsap.registerPlugin(ScrollTrigger);

export function QuestionModel(props) {
  const ref = React.useRef();
  const { nodes, materials } = useGLTF("/Models/q_mark.glb");
  const [active, setActive] = React.useState(false);
  const { setModelsPosition, modelsPosition } = useContext(Context);
  const positionSet = useRef(false);
  const change = useRef();

  useGSAP(() => {
    gsap.fromTo(
      ref.current.position,
      {
        y: -1.652,
      },
      {
        y: -1.5,
        scrollTrigger: {
          trigger: ".scroll-control",
          start: "top bottom",
          end: "top 95%",
          toggleActions: "play none none reverse",
          scrub: true,
        },
        ease: "none",
        immediateRender: false,
      }
    );
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: ".scroll-control",
        start: "top 95%",
        end: "top 25%",
        onLeave: () => {
          setActive(true);
        },
        onEnterBack: () => {
          setActive(false);
        },
        onUpdate: (self) => {
          gsap.to(change.current, {
            value: 1 - self.progress,
          });
        },
        toggleActions: "play none none reverse",
        scrub: true,
      },
    });
    tl.fromTo(
      ref.current.position,
      {
        x: 2.03,
        y: -1.5,
      },
      {
        x: 3,
        y: 1,
        duration: 2,
        immediateRender: false,
      }
    )
      .fromTo(
        ref.current.scale,
        {
          x: 0.024,
          y: 0.024,
          z: 0.024,
        },
        {
          x: 0.1,
          y: 0.1,
          z: 0.1,
          duration: 2,
        },
        "<"
      )
      .fromTo(
        ref.current.position,
        {
          y: 1,
        },
        {
          y: -3,
          duration: 2,
          immediateRender: false,
        }
      )
      .fromTo(
        ref.current.scale,
        {
          x: 0.1,
          y: 0.1,
          z: 0.1,
        },
        {
          x: 0.4,
          y: 0.4,
          z: 0.4,
          duration: 2,
          immediateRender: false,
        },
        "<"
      );
  });
  useFrame((state) => {
    if (active) {
      ref.current.rotation.y = (ref.current.rotation.y + 0.01) % (Math.PI * 2);
      if (!positionSet.current) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;

        const position = ref.current.position.clone();
        position.project(state.camera);
        position.x = position.x * widthHalf + widthHalf;
        position.y = -(position.y * height) / 2 + height / 2;
        const temp = modelsPosition;
        temp.qMark = [position.x, position.y];
        setModelsPosition(temp);
        positionSet.current = true;
        console.log(modelsPosition);
      }
    } else {
      positionSet.current = false;
      gsap.to(ref.current.rotation, {
        y: 0,
        duration: 1,
      });
    }

    // calculating position of the model wrt the screen width and height

    // console.log(position);
  });
  return (
    <group
      ref={ref}
      {...props}
      dispose={null}
      scale={0.035}
      position={[2.03, -1.652, 0]}
    >
      <ambientLight ref={change} intensity={0.5} />
      <group rotation={[Math.PI / 2, 0, 0]}>
        <mesh
          geometry={nodes.svgMeshShape3.geometry}
          material={materials["aiStandardSurface2.001"]}
          position={[-4.752, -0.788, -2]}
          scale={[1, 1.575, 1]}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/q_mark.glb");
